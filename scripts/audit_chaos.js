/* eslint-disable */ const { performance } = require('perf_hooks'); const fs = require('fs');  console.log("ðŸ’€ Starting Hostile Axis Audit (Chaos Suite)...");  // --- 1. The Immutable Ledger (Mock) --- let LEDGER = [     { id: 'genesis', type: 'INIT', amount: 0, balance_after: 100_000, timestamp: 0 } ];  // --- 2. The Vulnerable Logic (Simulation Target) --- // We simulate a class that MIGHT have race conditions if not careful class FinancialEngine {     constructor() {         this.currentBalance = 100_000;         this.locked = false;     }      // Invariant 1: Real Spending Power >= 0     // Invariant 2: Append Only     async processTransaction(txId, amount) {         // Simulate network delay (the "Gap of Death")         const balanceCheck = this.currentBalance;          await new Promise(r => setTimeout(r, Math.random() * 5)); // 0-5ms delay          if (balanceCheck - amount < 0) {             return { success: false, reason: "INVARIANT_VIOLATION: Negative Balance" };         }          // CRITICAL: This is where a race condition usually happens in bad systems         // If we don't re-check or lock, two threads pass the check above          this.currentBalance -= amount;          const event = {             id: txId,             type: 'SPEND',             amount: amount,             balance_after: this.currentBalance,             timestamp: Date.now()         };          LEDGER.push(event); // Simulated Append         return { success: true, event };     }      getBudget() { return this.currentBalance; } }  const engine = new FinancialEngine();  // --- 3. Attack Vectors ---  async function runAudit() {     const report = {         invariants: {},         attacks: []     };      // ATTACK 1: The "Double Tap" (Race Condition)     console.log("âš”ï¸  Executing Attack 1: Concurrent Double Spend...");     const initial = engine.getBudget();     const cost = initial * 0.6; // 60% of budget. Two of these should FAIL.      // Fire two requests simultaneously     const p1 = engine.processTransaction('attack_1_A', cost);     const p2 = engine.processTransaction('attack_1_B', cost);      const [r1, r2] = await Promise.all([p1, p2]);      const finalBalance = engine.getBudget();     const doubleSpendSuccess = (r1.success && r2.success);      if (doubleSpendSuccess) {         console.error("âŒ CRITICAL FAILURE: System allowed Double Spend!");         console.error(`   Started with ${initial}, spent ${cost} x2, now at ${finalBalance}`);         report.attacks.push({ type: "DOUBLE_SPEND", outcome: "FAILED_TO_PREVENT", details: "Race condition exploited." });     } else {         console.log("âœ… DEFENSE SUCCESS: Race condition blocked.");         report.attacks.push({ type: "DOUBLE_SPEND", outcome: "BLOCKED", details: "System rejected simultaneous invalid spend." });     }      // ATTACK 2: Ledger Mutability     console.log("\nâš”ï¸  Executing Attack 2: Ledger History Rewrite...");     const originalLedgerSize = LEDGER.length;     const originalEvent = JSON.stringify(LEDGER[1]); // The first spend      try {         // Attempt to mutate a past record         LEDGER[1].amount = 0;         LEDGER[1].balance_after = 1000000;          // In a real immutable system, this throws or is impossible.          // Here we simulate the CHECK of that invariant.         const currentEvent = JSON.stringify(LEDGER[1]);          if (originalEvent !== currentEvent) {             console.error("âŒ CRITICAL FAILURE: Ledger proved mutable!");             report.attacks.push({ type: "IMMUTABILITY", outcome: "FAILED", details: "Past records were altered in-memory." });         } else {             console.log("âœ… DEFENSE SUCCESS: Ledger is immutable.");         }     } catch (e) {         console.log("âœ… DEFENSE SUCCESS: Mutation threw error.");     }      // ATTACK 3: Negative Balance Force     console.log("\nâš”ï¸  Executing Attack 3: Force Negative Balance...");     const ruinousAmount = engine.getBudget() + 50000;     const r3 = await engine.processTransaction('ruin_attempt', ruinousAmount);      if (r3.success) {         console.error("âŒ CRITICAL FAILURE: Real Spending Power went negative!");         report.attacks.push({ type: "NEGATIVE_BALANCE", outcome: "FAILED", details: "System allowed spend exceeding balance." });     } else {         console.log("âœ… DEFENSE SUCCESS: Negative balance rejected.");         report.attacks.push({ type: "NEGATIVE_BALANCE", outcome: "BLOCKED", details: r3.reason });     }      // Report Generation     fs.writeFileSync('audit_results.json', JSON.stringify(report, null, 2));     console.log("\nðŸ“‹ Audit Complete. Findings written to audit_results.json"); }  runAudit(); 
